<body>
<p>This package provides a core Composite pattern model for controls and indicators such as potentiometers and switches, and their compositions.</p>
<p>Control is the abstract base class for this hierarchy. Control extends Observable so that user interfaces
and other problem domain components are loosely coupled to Controls. Control also implements a Chain of
Responsibility using notifyParent() which allows the root of a composite Control instance hierachy to
observe all child Control changes without using a vast number of Observers. Other Chains of Responsibility
exists in the various getControlPath() methods. The Chain of Responsibility pattern complements the
Composite pattern very well and they are often found together.</p>
<p>CompoundControl is the basic composite Control which does not allow its structure to be mutated
subsequent to construction.</p>
<p>CompoundControlChain extends CompoundControl to permit mutability of its structure using insert(), move() and delete() methods which operate on named Controls. CompoundControlChain notifies its Observers of these structural mutations using ChainMutation which uses the Command pattern to allow the loosely coupled Observers to
replicate or track the structure in a thread-safe manner.</p>
<p>BooleanControl controls a boolean state sutiable for switches (including momentary acting switches) and on/off indicators.</p>
<p>FloatControl controls a floating point state with a particular control law suitable for potentiometers and meters.</p>
<p>EnumControl controls an enumeration state suitable for multiple position switches.</p>
<p>LawControl controls a floating point state with a particular control law and is actually the direct superclass of FloatControl. It is generalised from FloatControl to allow more versatile construction.</p>
<p>ControlLaw is the interface that defines the simple contract for a control law.</p>
<p>AbstractLaw is an abstract implementation of ControlLaw with subclasses Linearlaw and LogLaw which are concrete implementations of linear and log control laws respectively.</p>
<p>ControlSelector is an interface which defines the contract for selecting or not selecting a particular Control in the context of walking a composite Control hierarchy. Simple unary and binary logical selectors are implemented as inner classes of the interface.</p>
<h2>Package uk.org.toot.control UML Class Diagram</h2>
<p>The Control composite is so critically important to other Toot packages that subclasses of Control are always coloured blue in UML class diagrams. Additionally interfaces are always coloured yellow.</p>
<p><image src="doc-files/control-1.gif"></p>
</body>